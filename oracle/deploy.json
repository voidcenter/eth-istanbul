{"language":"Solidity","sources":{"src/RepOracle.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interface/IRepOracleUser.sol\";\nimport \"./interface/IRepOracle.sol\";\nimport \"./interface/IUMAOracleV3.sol\";\n\ncontract RepOracleContract is IRepOracleContract, Ownable {\n    // user call back\n    mapping(bytes32 => address) public call_back_address; // request id to user address\n    mapping(bytes32 => address) public requesting_address;\n    // UMA \n    mapping(bytes32 => bytes32) public assertion_ids; //  assertion_ids to request_id\n    // Evidence & score\n    mapping(bytes32 => bytes) public evidence; // request id to evidence (IPFS hash), remove in production\n    mapping(address => IRepOracleContract.RepScore) public repScore;\n    \n    // axiom proof\n    mapping(bytes32 => uint256) public requestId_to_axiom_query_id;\n    mapping(uint256 => bytes32) public axiom_query_id_to_requestId;\n\n\n    uint256 public requestNonce;\n    IUMAOracleV3 oov3;\n    uint64 public assertionLiveness = 10;\n    bytes32 public immutable defaultIdentifier;\n    IERC20 public immutable defaultCurrency;\n    address public axiomV2Query;\n\n    // toggles for UMA & axiom\n    bool public enable_uma;\n    bool public enable_axiom;\n\n    constructor(address umaOracle, address _axiomV2Query, bool _uma, bool _axiom) Ownable(msg.sender) {\n        // Create an Optimistic Oracle V3 instance at the deployed address on GÃ¶rli.\n        toggleProviders(_uma, _axiom);\n\n        if (enable_axiom) {\n            axiomV2Query = _axiomV2Query;\n        }\n\n        if (enable_uma) {\n            oov3 = IUMAOracleV3(umaOracle);\n            defaultIdentifier = oov3.defaultIdentifier();\n            defaultCurrency = IERC20(oov3.defaultCurrency());\n        }\n        requestNonce = 0;\n    }\n\n    function setAxiom(address _axiomV2Query) public onlyOwner {\n        axiomV2Query = _axiomV2Query;\n    }\n\n    function toggleProviders(bool _uma, bool _axiom) public onlyOwner {\n        enable_uma = _uma;\n        enable_axiom = _axiom;\n    }\n\n    function setAssertionLiveness(uint64 _liveness) public onlyOwner {\n        assertionLiveness = _liveness;\n    }\n\n    function requestReputationScore(address _address, bool forceRefresh, uint256 expirationBlock)\n        external\n        returns (bytes32)\n    {\n        // Three possible way to get fresh score\n        // Forced Refresh\n        // First time calculating the score\n        // The score expired\n        bytes32 requestId = keccak256(abi.encodePacked(msg.sender, _address, block.timestamp, requestNonce));\n        requesting_address[requestId] = _address;\n        call_back_address[requestId] = msg.sender;\n\n        if (forceRefresh || repScore[_address].blocknumber == 0 || repScore[_address].blocknumber <= expirationBlock) {\n            emit RequestReceived(requestId, msg.sender, _address, requestNonce);\n            requestNonce += 1;\n        } else {\n            // directly callback\n            emit CachedRequestReceived(requestId, msg.sender, _address, requestNonce);\n            requestNonce += 1;\n            IRepOracleUser(msg.sender).reputationCallback(repScore[_address]);\n        }\n        return requestId;\n    }\n\n    function sendReputationScore(IRepOracleContract.RepScore calldata score, bytes memory _evidence)\n        external\n        onlyOwner\n        returns (bytes32 assertionId)\n    {\n        address userContractAddress = call_back_address[score.requestId];\n        require(userContractAddress != address(0), \"Request ID not found\");\n\n        if (enable_uma){\n            uint256 bond = oov3.getMinimumBond(address(defaultCurrency));\n            defaultCurrency.transferFrom(msg.sender, address(this), bond);\n            defaultCurrency.approve(address(oov3), bond);\n\n            assertionId = oov3.assertTruth(\n                _evidence,\n                owner(), // asserter, recieve the bond back at resolution if correct\n                address(this),\n                address(0), // no sovereign security\n                assertionLiveness,\n                defaultCurrency,\n                bond,\n                defaultIdentifier,\n                bytes32(0) // No domain.\n            );\n            assertion_ids[assertionId] = score.requestId;\n        } else {\n            assertionId = bytes32(0);\n        }\n\n\n        IRepOracleUser(userContractAddress).reputationCallback(score);\n\n        evidence[score.requestId] = _evidence;\n        repScore[score.requestingAddress] = score;\n        emit ReputationScoreSent(score.requestId, score.score, assertionId);\n\n        if (!enable_uma) {\n            IRepOracleUser(userContractAddress).commit(score.requestId);\n            emit UMAAssertionResolved(assertionId, score.requestId, true);\n        }\n    }\n\n    event UMAAssertionResolved(bytes32 indexed assertionId, bytes32 indexed requestId, bool _status);\n\n    // OptimisticOracleV3 resolve callback.\n    function assertionResolvedCallback(bytes32 assertionId, bool assertedTruthfully) public {\n        require(msg.sender == address(oov3));\n        bytes32 _requestId = assertion_ids[assertionId];\n        address userContractAddress = call_back_address[_requestId];\n        require(userContractAddress != address(0), \"Request ID not found\");\n\n        // If the assertion was true, then the data assertion is resolved.\n        // require Axiom proof to also pass\n        bool axiomPassed = !enable_axiom || (requestId_to_axiom_query_id[_requestId] != 0);\n        if (assertedTruthfully && axiomPassed) {\n            IRepOracleUser(userContractAddress).commit(_requestId);\n\n            emit UMAAssertionResolved(assertionId, _requestId, true);\n            // Else delete the data assertion if it was false to save gas.\n            // Enter reimbursement mechanism for users to get money.\n        } else {\n            IRepOracleUser(userContractAddress).rollback(_requestId);\n            // the score is invalid, remove\n            delete repScore[requesting_address[_requestId]];\n            emit UMAAssertionResolved(assertionId, _requestId, false);\n        }\n\n        // Gas savings\n        // delete assertion_ids[assertionId];\n        // delete call_back_address[_requestId];\n    }\n\n    event AxiomVerificationSuccess(bytes32 indexed requestId, uint256 queryId);\n\n    function axiomV2Callback(\n        uint64 sourceChainId,\n        address caller,\n        bytes32 querySchema,\n        uint256 queryId,\n        bytes32[] calldata axiomResults,\n        bytes calldata extraData // <-- we can requestId from this\n    ) external { \n        // validate msg.sender against the AxiomV2Query address\n        require(msg.sender == axiomV2Query || msg.sender == owner());\n        require(caller == owner());     \n        bytes32 requestId = bytes32(extraData);\n        address userContractAddress = call_back_address[requestId];\n        // validate the sourceChainId, caller, querySchema, and queryId\n        \n        IRepOracleContract.RepScore memory _unverifiedScore = repScore[requesting_address[requestId]];\n\n        // verify axiom result\n        emit AxiomVerificationSuccess(requestId, queryId);\n\n        // perform your application logic\n        requestId_to_axiom_query_id[requestId]= queryId;\n        axiom_query_id_to_requestId[queryId] = requestId;\n\n    }\n\n    // Call this once liveness period is over\n    function settelUMAAssertion(bytes32 assertionId) public {\n        bool assertionResult = oov3.settleAndGetAssertionResult(assertionId);\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"},"src/interface/IRepOracleUser.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IRepOracle.sol\";\n\ninterface IRepOracleUser {\n    function reputationCallback(IRepOracleContract.RepScore memory score) external;\n\n    function commit(bytes32 _requestId) external;\n\n    function rollback(bytes32 _requestId) external;\n}\n\nabstract contract RepOracleUser is IRepOracleUser {\n    address reputationOracle;\n    IRepOracleContract oracle;\n\n    modifier onlyRepOracle() {\n        require(msg.sender == reputationOracle);\n        _;\n    }\n\n    constructor(address _reputationOracle) {\n        reputationOracle = _reputationOracle;\n        oracle = IRepOracleContract(_reputationOracle);\n    }\n    // this function will get callbacked immediately a reputation score is computed, however, at this point\n    // the score is yet to be verified.\n\n    function reputationCallback(IRepOracleContract.RepScore memory score) external virtual;\n\n    // when this function is called, the requested score is verified\n    function commit(bytes32 _requestId) external virtual;\n\n    // when this function is called, the score verification failed, rollback anything if needed\n    // this is function will never be called if requested has already been committed.\n    function rollback(bytes32 _requestId) external virtual;\n}\n"},"src/interface/IRepOracle.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IRepOracleContract {\n\n    struct OnchainDetails {\n\n        uint256 allChainMaxNounce;\n        uint256 nonce;\n        uint256 allChainMaxAge;\n        uint256 age;\n        uint256 allChainUsdBalance;\n        uint256 usdBalance;\n    }\n\n    struct SocialDetail {\n        bool worldcoinConfirmed;\n        uint256 lensFollowers;\n        uint256 twitterFollowers;\n        uint256 noncompliantTxns;\n        bytes ens;\n    }\n\n    struct RepScore {\n        address requestingAddress;\n        int256 score;\n        uint256 blocknumber;\n        bool isCompliant; // multi-chain\n        bool isHuman;\n        SocialDetail socialDetail;\n        OnchainDetails onchainDetail;\n        bytes32 requestId;\n        bytes ipfs_hash;\n    }\n\n    event BatchRequestReceived(\n        bytes32 indexed requestId, address indexed requester, address[] addresses, uint256 nonce\n    );\n    event RequestReceived(bytes32 indexed requestId, address indexed requester, address addresses, uint256 nonce);\n\n    event CachedRequestReceived(bytes32 indexed requestId, address indexed requester, address addresses, uint256 nonce);\n\n    event ReputationScoreSent(bytes32 indexed requestId, int256 reputationScore, bytes32 indexed assertionId);\n\n    // function requestBatchReputationScore(address[] calldata _addresses) external returns (bytes32);\n\n    function requestReputationScore(address _address, bool forceRefresh, uint256 expirationBlock)\n        external\n        returns (bytes32);\n\n    function sendReputationScore(IRepOracleContract.RepScore calldata score, bytes memory _evidence)\n        external\n        returns (bytes32 assertionId);\n\n    function settelUMAAssertion(bytes32 assertionId) external;\n}\n"},"src/interface/IUMAOracleV3.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.23;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Optimistic Oracle V3 Interface that callers must use to assert truths about the world.\n */\ninterface IUMAOracleV3 {\n    // Struct grouping together the settings related to the escalation manager stored in the assertion.\n    struct EscalationManagerSettings {\n        bool arbitrateViaEscalationManager; // False if the DVM is used as an oracle (EscalationManager on True).\n        bool discardOracle; // False if Oracle result is used for resolving assertion after dispute.\n        bool validateDisputers; // True if the EM isDisputeAllowed should be checked on disputes.\n        address assertingCaller; // Stores msg.sender when assertion was made.\n        address escalationManager; // Address of the escalation manager (zero address if not configured).\n    }\n\n    // Struct for storing properties and lifecycle of an assertion.\n    struct Assertion {\n        EscalationManagerSettings escalationManagerSettings; // Settings related to the escalation manager.\n        address asserter; // Address of the asserter.\n        uint64 assertionTime; // Time of the assertion.\n        bool settled; // True if the request is settled.\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\n        uint64 expirationTime; // Unix timestamp marking threshold when the assertion can no longer be disputed.\n        bool settlementResolution; // Resolution of the assertion (false till resolved).\n        bytes32 domainId; // Optional domain that can be used to relate the assertion to others in the escalationManager.\n        bytes32 identifier; // UMA DVM identifier to use for price requests in the event of a dispute.\n        uint256 bond; // Amount of currency that the asserter has bonded.\n        address callbackRecipient; // Address that receives the callback.\n        address disputer; // Address of the disputer.\n    }\n\n    // Struct for storing cached currency whitelist.\n    struct WhitelistedCurrency {\n        bool isWhitelisted; // True if the currency is whitelisted.\n        uint256 finalFee; // Final fee of the currency.\n    }\n\n    /**\n     * @notice Returns the default identifier used by the Optimistic Oracle V3.\n     * @return The default identifier.\n     */\n    function defaultIdentifier() external view returns (bytes32);\n\n    function defaultCurrency() external view returns (address);\n\n    /**\n     * @notice Fetches information about a specific assertion and returns it.\n     * @param assertionId unique identifier for the assertion to fetch information for.\n     * @return assertion information about the assertion.\n     */\n    function getAssertion(bytes32 assertionId) external view returns (Assertion memory);\n\n    /**\n     * @notice Asserts a truth about the world, using the default currency and liveness. No callback recipient or\n     * escalation manager is enabled. The caller is expected to provide a bond of finalFee/burnedBondPercentage\n     * (with burnedBondPercentage set to 50%, the bond is 2x final fee) of the default currency.\n     * @dev The caller must approve this contract to spend at least the result of getMinimumBond(defaultCurrency).\n     * @param claim the truth claim being asserted. This is an assertion about the world, and is verified by disputers.\n     * @param asserter receives bonds back at settlement. This could be msg.sender or\n     * any other account that the caller wants to receive the bond at settlement time.\n     * @return assertionId unique identifier for this assertion.\n     */\n    function assertTruthWithDefaults(bytes memory claim, address asserter) external returns (bytes32);\n\n    /**\n     * @notice Asserts a truth about the world, using a fully custom configuration.\n     * @dev The caller must approve this contract to spend at least bond amount of currency.\n     * @param claim the truth claim being asserted. This is an assertion about the world, and is verified by disputers.\n     * @param asserter receives bonds back at settlement. This could be msg.sender or\n     * any other account that the caller wants to receive the bond at settlement time.\n     * @param callbackRecipient if configured, this address will receive a function call assertionResolvedCallback and\n     * assertionDisputedCallback at resolution or dispute respectively. Enables dynamic responses to these events. The\n     * recipient _must_ implement these callbacks and not revert or the assertion resolution will be blocked.\n     * @param escalationManager if configured, this address will control escalation properties of the assertion. This\n     * means a) choosing to arbitrate via the UMA DVM, b) choosing to discard assertions on dispute, or choosing to\n     * validate disputes. Combining these, the asserter can define their own security properties for the assertion.\n     * escalationManager also _must_ implement the same callbacks as callbackRecipient.\n     * @param liveness time to wait before the assertion can be resolved. Assertion can be disputed in this time.\n     * @param currency bond currency pulled from the caller and held in escrow until the assertion is resolved.\n     * @param bond amount of currency to pull from the caller and hold in escrow until the assertion is resolved. This\n     * must be >= getMinimumBond(address(currency)).\n     * @param identifier UMA DVM identifier to use for price requests in the event of a dispute. Must be pre-approved.\n     * @param domainId optional domain that can be used to relate this assertion to others in the escalationManager and\n     * can be used by the configured escalationManager to define custom behavior for groups of assertions. This is\n     * typically used for \"escalation games\" by changing bonds or other assertion properties based on the other\n     * assertions that have come before. If not needed this value should be 0 to save gas.\n     * @return assertionId unique identifier for this assertion.\n     */\n    function assertTruth(\n        bytes memory claim,\n        address asserter,\n        address callbackRecipient,\n        address escalationManager,\n        uint64 liveness,\n        IERC20 currency,\n        uint256 bond,\n        bytes32 identifier,\n        bytes32 domainId\n    ) external returns (bytes32);\n\n    /**\n     * @notice Fetches information about a specific identifier & currency from the UMA contracts and stores a local copy\n     * of the information within this contract. This is used to save gas when making assertions as we can avoid an\n     * external call to the UMA contracts to fetch this.\n     * @param identifier identifier to fetch information for and store locally.\n     * @param currency currency to fetch information for and store locally.\n     */\n    function syncUmaParams(bytes32 identifier, address currency) external;\n\n    /**\n     * @notice Resolves an assertion. If the assertion has not been disputed, the assertion is resolved as true and the\n     * asserter receives the bond. If the assertion has been disputed, the assertion is resolved depending on the oracle\n     * result. Based on the result, the asserter or disputer receives the bond. If the assertion was disputed then an\n     * amount of the bond is sent to the UMA Store as an oracle fee based on the burnedBondPercentage. The remainder of\n     * the bond is returned to the asserter or disputer.\n     * @param assertionId unique identifier for the assertion to resolve.\n     */\n    function settleAssertion(bytes32 assertionId) external;\n\n    /**\n     * @notice Settles an assertion and returns the resolution.\n     * @param assertionId unique identifier for the assertion to resolve and return the resolution for.\n     * @return resolution of the assertion.\n     */\n    function settleAndGetAssertionResult(bytes32 assertionId) external returns (bool);\n\n    /**\n     * @notice Fetches the resolution of a specific assertion and returns it. If the assertion has not been settled then\n     * this will revert. If the assertion was disputed and configured to discard the oracle resolution return false.\n     * @param assertionId unique identifier for the assertion to fetch the resolution for.\n     * @return resolution of the assertion.\n     */\n    function getAssertionResult(bytes32 assertionId) external view returns (bool);\n\n    /**\n     * @notice Returns the minimum bond amount required to make an assertion. This is calculated as the final fee of the\n     * currency divided by the burnedBondPercentage. If burn percentage is 50% then the min bond is 2x the final fee.\n     * @param currency currency to calculate the minimum bond for.\n     * @return minimum bond amount.\n     */\n    function getMinimumBond(address currency) external view returns (uint256);\n\n    event AssertionMade(\n        bytes32 indexed assertionId,\n        bytes32 domainId,\n        bytes claim,\n        address indexed asserter,\n        address callbackRecipient,\n        address escalationManager,\n        address caller,\n        uint64 expirationTime,\n        IERC20 currency,\n        uint256 bond,\n        bytes32 indexed identifier\n    );\n\n    event AssertionDisputed(bytes32 indexed assertionId, address indexed caller, address indexed disputer);\n\n    event AssertionSettled(\n        bytes32 indexed assertionId,\n        address indexed bondRecipient,\n        bool disputed,\n        bool settlementResolution,\n        address settleCaller\n    );\n\n    event AdminPropertiesSet(IERC20 defaultCurrency, uint64 defaultLiveness, uint256 burnedBondPercentage);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"}},"settings":{"remappings":["@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","ds-test/=lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"":["ast"],"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","libraries":{}}}